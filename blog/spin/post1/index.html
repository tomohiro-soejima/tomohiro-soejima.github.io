<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=google-site-verification  content=kpHYuhI7h81XOVXWEEDn36Yf-_kjnQVC7Acac_desn8  /> <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/jemdoc.css"> <link rel=apple-touch-icon  sizes=180x180  href="/assets/apple-touch-icon.png"> <link rel=icon  type="image/png" sizes=32x32  href="/assets/favicon-32x32.png"> <link rel=icon  type="image/png" sizes=16x16  href="/assets/favicon-16x16.png"> <link rel=manifest  href="/assets/site.webmanifest"> <title>How to create transverse field Ising model Hamiltonian</title> <table id=tlayout > <tr valign=top > <td id=layout-menu > <div class="menu-item "><a href="/">home</a></div> <div class=menu-category >julia</div> <div class="menu-item "><a href="/blog/julia/post1/">Closure</a></div> <div class="menu-item "><a href="/blog/julia/post2/">QuickJulia</a></div> <div class=menu-category >spin chain</div> <div class="menu-item "><a href="/blog/spin/post1/">sparseTFIM</a></div> <div class=menu-category >GitHub</div> <div class="menu-item "><a href="/blog/GitHub/post1/">Why GitHub?</a></div> <td id=layout-content > <br> <div class="container blog-title"> <h1>How to create transverse field Ising model Hamiltonian</h1> <h3> <span style="font-weight: lighter;"> posted: 2020-11-11 | last modified: 2022-01-31 </span> | <span style="font-weight: bold;">Tomohiro Soejima</span> </h3> </div> <br> <div class=franklin-content ><p>This is a short note explaining how to construct the sparse representation of the transverse-field Ising model. It is intended as a reading material for <a href="https://berkeleyphysicsdrp.wixsite.com/physicsberkeleydrp">Berkeley Physics DRP</a>, but I figured this might be useful for broader audience as well.</p> <p>The article assumes knowledge of quantum mechanics &#40;especially familiarity with spin-1/2 and Pauli matrices&#41; and some familiarity with coding. All the code exmaples are provides in <a href="https://julialang.org/">Julia</a>, but you can more or less treat them as pseudocodes if you are unfamiliar with the language.</p> <div class=franklin-toc ><ol><li><a href="#transverse-field_ising_model">Transverse-field Ising model</a><ol><li><a href="#choice_of_basis_states">Choice of basis states</a><li><a href="#sparcity_of_the_matrix">Sparcity of the matrix</a><li><a href="#sparse_representation">Sparse representation</a><li><a href="#diagonalization">Diagonalization</a></ol></ol></div> <h2 id=transverse-field_ising_model ><a href="#transverse-field_ising_model" class=header-anchor >Transverse-field Ising model</a></h2> <p>Transverse filed Ising model&#40;TFIM&#41; with open boundary condition is given by the following Hamiltonian:</p> \[ H = -J \sum_{i=1}^{N-1} S_i^x S_{i+1}^x + h \sum_{i=1}^N S_i^z\] <p>where \(S^\mu\) are Pauli spin matrices for spin-1/2. We hope to represent this as a matrix, so that we can diagonalize it to find the ground state.</p> <h3 id=choice_of_basis_states ><a href="#choice_of_basis_states" class=header-anchor >Choice of basis states</a></h3> <p>We first need to figure out how to represent our basis states. Following convention, we map spin-up and spin-down spin to 0 and 1:</p> \[ |z; +1\rangle \rightarrow |0\rangle, |z; -1\rangle \rightarrow |1\rangle. \] <p>A state with \(N\)-spins can then be represented by a string of \(N\) \(0\)&#39;s and \(1\)&#39;s. For example, a state with \(N\) spin-down&#39;s is \(|111\cdots 111>\). Such a string can be interepreted as a binary number. Therefore, we will label our basis states by integer in range \([0, 2^N-1]\) such that the binary representation of the index corresponds to the state&#39;s spin configuration. The function for extracting spin configuration is straightforward:</p> <pre><code class=language-julia >N &#61; 4
index &#61; 3
configuration &#61; string&#40;index, base&#61;2, pad&#61;N&#41;
@show configuration</code></pre><pre><code class="plaintext code-output">configuration = "0011"
</code></pre> <h3 id=sparcity_of_the_matrix ><a href="#sparcity_of_the_matrix" class=header-anchor >Sparcity of the matrix</a></h3> <p>A Hamiltonian for \(N\) spin-1/2 spins is a \(2^N \times 2^N\) dimensional matrix. In order to store it densely, we would store \(4^N\) entries. This quickly becomes impractical: the size of the matrix goes past 1 TB at mere 18 spins.</p> <p>However, the matrix is in fact very sparse. Let&#39;s look at the action of \(S^x S^x\) on the basis states. \(S^x\) flips spin, so its action is:</p> \[ S^x_i S^x_{i+1} |\cdots 01 \cdots \rangle = |\cdots 10 \cdots \rangle. \] <p>Crucially, acting with \(S^x S^x\) creates another basis state. Therefore, for given \(S_i^x S_{i+1}^x\), <strong>there is at most one basis state \(k\) for each basis state \(\ell\) such that \( \langle k | S^x_i S^x{i+1} |\ell\rangle\) is nonzero</strong>. Using this counting for all \(i\) and \(\ell\), we conclude that there are at most \(N 2^N\) nonzero metrix elements of H coming from \(S^x S^x\) terms. Similar counting argument tells us there are at most \(2^N\) terms from \(S^z\) terms.</p> <p>Therefore, the sparcity&#40;the number of nonzero entries divided by the size&#41; of this matrix is at most </p> \[ \frac{(N+1) 2^N}{ 4^N} = \frac{N+1}{2^N}.\] <p>As \(N\) increases, the matrix becomes very sparse.</p> <h3 id=sparse_representation ><a href="#sparse_representation" class=header-anchor >Sparse representation</a></h3> <p>There are different ways to represent a sparse matrix, each suitable for different purposes. For sparse matrix construction, we use the <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_&#40;COO&#41;"><strong>coordinate list &#40;COO&#41;</strong> representation</a>. The representation stores a list of row indices <code>I</code>, a list of column indices <code>J</code>, and a list of values <code>V</code>, such that the <code>n</code>th nonzero value has row index <code>I&#91;n&#93;</code>, column index <code>J&#91;n&#93;</code>, and value <code>V&#91;n&#93;</code>.</p> <p>For our problem, we first fix the column index <code>column_index</code>, and a particular term in the Hamiltonian \(S_i^x S_{i+1}^x\). Then, we can calculate the unique <code>row_index</code> such that <code>value&#61;</code> \(\langle\texttt{row\_index} | S_i^x S_{i+1}^x | \texttt{column\_index} \rangle\) is nonzero. We repeat this for all column indices and \(S_i^x S_{i+1}^x\) terms. Here is a Julia code for doing this:</p> <pre><code class=language-julia >&quot;&quot;&quot;
A version that only does Sx terms. Generalizing this to include Sz terms is straightforward.
&quot;&quot;&quot;
function create_sparse_TFIM&#40;N, J&#41;
    I &#61; Int&#91;&#93;
    J &#61; Int&#91;&#93;
    V &#61; ComplexF64&#91;&#93;
    for column_index in 1:2^N-1, i in 1:N-1
        row_index &#61; get_unique_row_index&#40;column_index, i, N&#41;
        push&#33;&#40;I, row_index&#41;
        push&#33;&#40;J, column_index&#41;
        push&#33;&#40;V, J&#41;
    end
    return I, J, V
end</code></pre> <h4 id=how_to_get_the_unique_row_index ><a href="#how_to_get_the_unique_row_index" class=header-anchor >How to get the unique <code>row_index</code></a></h4> <p>It is a fun exercise to think about how to implement <code>get_unique_row_index</code> function. You should think about this yourself&#33; Read on once you come up with your own implementation.</p> <p>Here is one implementation:</p> <pre><code class=language-julia >function get_unique_row_index&#40;column_index, i, N&#41;
    reference_bits &#61; 3 &lt;&lt; &#40;N &#43; i - 3&#41;
    return column_index ⊻ reference_bits
end</code></pre> <p>Where <code>&lt;&lt;</code> is the left <a href="https://stackoverflow.com/questions/141525/what-are-bitwise-shift-bit-shift-operators-and-how-do-they-work">bitwise shift operator</a> and <code>⊻</code> is the XOR operator. Why does this work? To see this, notice that spin flip can be implemented via XOR operation:</p> \[ (\cdots 10 \cdots) \oplus (\cdots 11 \cdots) = (\cdots 01 \cdots) \] <p>The bit shift operator adjusts the location of \(11\) depending on the operator location \(i\).</p> <h3 id=diagonalization ><a href="#diagonalization" class=header-anchor >Diagonalization</a></h3> <p>Once we are done creating the COO representation, we can transform that to other formats that are more suitable for linear algebra. Julia provides a builtin <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_&#40;CSC_or_CCS&#41;"><strong>compressed sparse row&#40;CSC&#41; representation</strong></a>, which can be created as follows:</p> <pre><code class=language-julia >using SparseArrays
I, J, V &#61; create_sparse_TFIM&#40;N, J&#41;
H &#61; sparse&#40;I, J, V&#41;</code></pre> <p>Now you can use standard sparse eigensolvers. Julia provides a binding to <code>arpack</code>, which we can call like this:</p> <pre><code class=language-julia >using Arpack
vals, vecs &#61; eigs&#40;H, nev&#61;3&#41;</code></pre> <p>Other scientific languages &#40;Python, R, Matlab, etc.&#41; have their own libraries for sparse matrix linear algebra.</p> <div class=page-foot > <div class=copyright > &copy; Tomohiro Soejima. Last modified: January 31, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> </div> </div> </div> </table> <script src="/libs/katex/katex.min.js"></script> <script src="/libs/katex/auto-render.min.js"></script> <script>renderMathInElement(document.body)</script> <script src="/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script>